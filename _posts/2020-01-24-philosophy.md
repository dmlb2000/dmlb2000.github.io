---
layout: post
title: Personal Philosophy on Software!
image: 
---

# Philosophy and Truth in Software

[Neil deGrasse Tyson](https://twitter.com/neiltyson) provides a
basis for discussing
[truth](https://twitter.com/neiltyson/status/771176428880617472?lang=en).
This foundation can be applied to software in similar ways and with
striking parallels to modern science.

## Objective Truth in Software

Every piece of software is an expression of a thought. This is
similar to a scientific hypothesis or a guess that needs to be
tested. Some software is right and some are wrong. Only
when we have others use and review our software do we begin to change
our software into well established mature applications (an
objective truth).

Some objective truths in software are broadly applicable and are
well established. Security software contain many examples,
[OpenSSL](https://www.openssl.org/) being a perfect example. This
library is critical to secure a large portion of the traffic over
the internet. It is also able to run on many different networked
devices (i.e. cloud, PCs, TVs, phones and IoT devices).

Other objective truths in software are more localized and focused
but are nonetheless very important and mature. Two such technologies
competing in data center storage are,
[Fiber Channel](https://fibrechannel.org/) and 
[Infiniband](https://www.openfabrics.org/). These two technologies
have well established open source libraries and APIs that
enable vendors to build storage systems that service
compute resources in a data center.

## Personal Truth in Software

This is the standard religious debate in software that we all know
about. Unix geeks remember the VI vs. EMACS debate. More modern
debates are, Linux vs. Windows or Containers vs. Virtual Machines,
the list can go on.

The big difference between modern religious debates and software
debates come from the universal objective truth that governs all
software,
[Turing Completeness](https://simple.wikipedia.org/wiki/Turing_complete).
Computability theory is a very deep subject and is an exercise for
the reader. It practically means that computing professionals tend to
pick a side so they only have to learn one thing instead of two,
because they know the two sides are equivalent. This makes them more
efficient doing their real work.

## Political Truth in Software

The political truths in software are also well known. They happen at
different scales from intra-personal to inter-company. 

At the personal level we do this all the time. Software developers
will jump to implementation to early without doing enough research.
We may over-complicate the architecture trying to solve a larger
problem the client does not have. We lie to ourselves, thinking what
we are doing is right. Luckily, agile development methods
curb these individual mistakes quickly before they become costly.

At the industry scale often powerful companies will push
inferior products, competing in emerging spaces. Other products get
pushed out, because the powerful company uses their market share to
force the technology in a direction that benefits them. Power plays
like this, set back technology in that space a decade or more,
hindering innovation over that time.

# Conclusion

Truth in software is still a moving target. I like to think I've got
all the answers, but I know that I'm lying to myself. All I know is
that the discussion above seems to fit my perspective on software.

My perspective is, there is no good and bad software. Software is
like having a conversation with someone, only you wrote every line of
your side years ago. So, bad software is just a one-sided
conversation that completely missed its audience.